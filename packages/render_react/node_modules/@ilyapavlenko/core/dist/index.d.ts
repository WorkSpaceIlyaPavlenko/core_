import * as zod from 'zod';
import zod__default, { z } from 'zod';
import * as zod_v4_core from 'zod/v4/core';
import { FunctionComponent, SVGProps, ElementType } from 'react';
import * as effector from 'effector';

declare function isObject(item: unknown): item is object;
declare const UtilsDynamicNodeCore: zod__default.ZodObject<{
    id: zod__default.ZodString;
    kind: zod__default.ZodString;
}, zod__default.core.$strip>;
declare const UtilsSignalSchema: zod__default.ZodDiscriminatedUnion<[zod__default.ZodObject<{
    kind: zod__default.ZodLiteral<string>;
    event: zod__default.ZodEnum<{
        [x: string]: string;
    }>;
}, zod__default.core.$strip>, zod__default.ZodObject<{
    kind: zod__default.ZodLiteral<string>;
    event: zod__default.ZodEnum<{
        [x: string]: string;
    }>;
}, zod__default.core.$strip>], "kind">;

/**
 * Core declarative node of the Cubro scene graph.
 *
 * This type defines the minimal universal structure for all nodes
 * used in the configuration (AST) layer of the system.
 *
 * IMPORTANT:
 * - This structure is **declarative only**.
 * - It must NOT contain any runtime state, DOM references, effects, or subscriptions.
 * - It is used as an input for Engine, diffing, and scene rendering.
 *
 * @typeParam T - Type of child nodes.
 */
type OwnerDynamicParentType = z.infer<typeof UtilsDynamicNodeCore>;
interface NodeCoreStructType<T = unknown> {
    /**
     * Stable unique identifier of the node.
     */
    id: string;
    /**
     * Semantic kind of the node.
     */
    kind: string;
    /**
     * Logical owner or contextual group of the node.
     */
    owner?: OwnerDynamicParentType | string | null;
    /**
     * Declarative child nodes.
     */
    children?: T[];
}
interface NodeAstStateType {
    visible?: boolean;
    disabled?: boolean;
    active?: boolean;
    loading?: boolean;
}
interface NodeAstBehaviorType<T> {
    emit: Array<SignalContract<T>>;
}
interface NodeAstConfigType<T = unknown, P = unknown> {
    core: NodeCoreStructType<T>;
    initialState?: NodeAstStateType;
    behavior?: NodeAstBehaviorType<unknown>;
    props?: P;
}
type UiEventType = 'onClick' | 'onMouseEnter' | 'onMouseLeave' | 'onFocus' | 'onBlur' | 'onKeyDown' | 'onKeyUp';
type SystemSignalType = 'open' | 'close' | 'setVisible' | 'setDisabled' | 'setActive' | 'setLoading';
type SignalUIType = {
    kind: 'ui';
    event: UiEventType;
};
type SignalSysType = {
    kind: 'system';
    event: SystemSignalType;
};
type SignalType = z.infer<typeof UtilsSignalSchema>;
interface SignalContract<T = unknown> {
    targetId: string;
    elKind: string;
    signal: SignalType;
    payload?: T;
}

declare class Engine {
    private inRun;
    private childrenIds;
    private validator;
    private provider;
    constructor();
    run(config: NodeAstConfigType): void;
    dynamic(data: NodeAstConfigType | Array<NodeAstConfigType>): void;
    private storeProvider;
    private signalsProvider;
    private parseNode;
    private hasChild;
    private getChildrenIds;
    private ownerByChildren;
    private childrenProvide;
    private setChildrenIds;
}

declare const Validator: {
    NodeAstStateSchema: zod.ZodObject<{
        visible: zod.ZodOptional<zod.ZodBoolean>;
        disabled: zod.ZodOptional<zod.ZodBoolean>;
        active: zod.ZodOptional<zod.ZodBoolean>;
        loading: zod.ZodOptional<zod.ZodBoolean>;
    }, zod_v4_core.$strip>;
    AstButtonPropsSchema: zod.ZodObject<{
        className: zod.ZodOptional<zod.ZodString>;
        classNameImgWp: zod.ZodOptional<zod.ZodString>;
        classNameImg: zod.ZodOptional<zod.ZodString>;
        classNameSvg: zod.ZodOptional<zod.ZodString>;
        importance: zod.ZodOptional<zod.ZodEnum<{
            default: "default";
            main: "main";
            supplementary: "supplementary";
        }>>;
        backgroundStyle: zod.ZodOptional<zod.ZodString>;
        text: zod.ZodOptional<zod.ZodString>;
        img: zod.ZodOptional<zod.ZodUnknown>;
        svg: zod.ZodOptional<zod.ZodUnknown>;
        imgLocation: zod.ZodOptional<zod.ZodEnum<{
            left: "left";
            right: "right";
        }>>;
        imgWidth: zod.ZodOptional<zod.ZodNumber>;
        imgHeight: zod.ZodOptional<zod.ZodNumber>;
    }, zod_v4_core.$strip>;
    RuntimePropsButtonSchema: zod.ZodIntersection<zod.ZodObject<{
        className: zod.ZodOptional<zod.ZodString>;
        classNameImgWp: zod.ZodOptional<zod.ZodString>;
        classNameImg: zod.ZodOptional<zod.ZodString>;
        classNameSvg: zod.ZodOptional<zod.ZodString>;
        importance: zod.ZodOptional<zod.ZodEnum<{
            default: "default";
            main: "main";
            supplementary: "supplementary";
        }>>;
        backgroundStyle: zod.ZodOptional<zod.ZodString>;
        text: zod.ZodOptional<zod.ZodString>;
        img: zod.ZodOptional<zod.ZodUnknown>;
        svg: zod.ZodOptional<zod.ZodUnknown>;
        imgLocation: zod.ZodOptional<zod.ZodEnum<{
            left: "left";
            right: "right";
        }>>;
        imgWidth: zod.ZodOptional<zod.ZodNumber>;
        imgHeight: zod.ZodOptional<zod.ZodNumber>;
    }, zod_v4_core.$strip>, zod.ZodObject<{
        visible: zod.ZodOptional<zod.ZodBoolean>;
        disabled: zod.ZodOptional<zod.ZodBoolean>;
        active: zod.ZodOptional<zod.ZodBoolean>;
        loading: zod.ZodOptional<zod.ZodBoolean>;
    }, zod_v4_core.$strip>>;
    AstTextPropsSchema: zod.ZodObject<{
        className: zod.ZodOptional<zod.ZodString>;
        text: zod.ZodOptional<zod.ZodUnion<readonly [zod.ZodString, zod.ZodNumber]>>;
        animateTyping: zod.ZodOptional<zod.ZodBoolean>;
        typingSpeed: zod.ZodOptional<zod.ZodNumber>;
        startDelay: zod.ZodOptional<zod.ZodNumber>;
    }, zod_v4_core.$strip>;
    AstTextInitialStateSchema: zod.ZodObject<{
        tag: zod.ZodCustom<keyof HTMLElementTagNameMap, keyof HTMLElementTagNameMap>;
    }, zod_v4_core.$strip>;
    RuntimePropsTextSchema: zod.ZodIntersection<zod.ZodIntersection<zod.ZodObject<{
        className: zod.ZodOptional<zod.ZodString>;
        text: zod.ZodOptional<zod.ZodUnion<readonly [zod.ZodString, zod.ZodNumber]>>;
        animateTyping: zod.ZodOptional<zod.ZodBoolean>;
        typingSpeed: zod.ZodOptional<zod.ZodNumber>;
        startDelay: zod.ZodOptional<zod.ZodNumber>;
    }, zod_v4_core.$strip>, zod.ZodObject<{
        tag: zod.ZodCustom<keyof HTMLElementTagNameMap, keyof HTMLElementTagNameMap>;
    }, zod_v4_core.$strip>>, zod.ZodObject<{
        visible: zod.ZodOptional<zod.ZodBoolean>;
        disabled: zod.ZodOptional<zod.ZodBoolean>;
        active: zod.ZodOptional<zod.ZodBoolean>;
        loading: zod.ZodOptional<zod.ZodBoolean>;
    }, zod_v4_core.$strip>>;
    AstContainerCoreSchema: zod.ZodObject<{
        kind: zod.ZodLiteral<"container">;
        layout: zod.ZodOptional<zod.ZodEnum<{
            FlexLayout: "FlexLayout";
            GridLayout: "GridLayout";
            AbsoluteLayout: "AbsoluteLayout";
            InlineLayout: "InlineLayout";
            DefaultLayout: "DefaultLayout";
        }>>;
    }, zod_v4_core.$strip>;
    AstContainerPropsSchema: zod.ZodObject<{
        className: zod.ZodOptional<zod.ZodString>;
        display: zod.ZodOptional<zod.ZodEnum<{
            flex: "flex";
            grid: "grid";
            inline: "inline";
        }>>;
        direction: zod.ZodOptional<zod.ZodEnum<{
            row: "row";
            column: "column";
        }>>;
        align: zod.ZodOptional<zod.ZodEnum<{
            center: "center";
            start: "start";
            end: "end";
        }>>;
        gap: zod.ZodOptional<zod.ZodNumber>;
        position: zod.ZodOptional<zod.ZodEnum<{
            absolute: "absolute";
            relative: "relative";
            fixed: "fixed";
            static: "static";
            sticky: "sticky";
        }>>;
    }, zod_v4_core.$strip>;
    RuntimePropsContainerSchema: zod.ZodIntersection<zod.ZodObject<{
        className: zod.ZodOptional<zod.ZodString>;
        display: zod.ZodOptional<zod.ZodEnum<{
            flex: "flex";
            grid: "grid";
            inline: "inline";
        }>>;
        direction: zod.ZodOptional<zod.ZodEnum<{
            row: "row";
            column: "column";
        }>>;
        align: zod.ZodOptional<zod.ZodEnum<{
            center: "center";
            start: "start";
            end: "end";
        }>>;
        gap: zod.ZodOptional<zod.ZodNumber>;
        position: zod.ZodOptional<zod.ZodEnum<{
            absolute: "absolute";
            relative: "relative";
            fixed: "fixed";
            static: "static";
            sticky: "sticky";
        }>>;
    }, zod_v4_core.$strip>, zod.ZodObject<{
        visible: zod.ZodOptional<zod.ZodBoolean>;
        disabled: zod.ZodOptional<zod.ZodBoolean>;
        active: zod.ZodOptional<zod.ZodBoolean>;
        loading: zod.ZodOptional<zod.ZodBoolean>;
    }, zod_v4_core.$strip>>;
    UtilsIsObject: typeof isObject;
    UtilsIsNodeCoreSchema: zod.ZodObject<{
        id: zod.ZodString;
        kind: zod.ZodString;
        owner: zod.ZodOptional<zod.ZodNullable<zod.ZodString>>;
        children: zod.ZodOptional<zod.ZodArray<zod.ZodUnknown>>;
        layout: zod.ZodOptional<zod.ZodString>;
    }, zod_v4_core.$strip>;
    UtilsIsNodeInitialStateSchema: zod.ZodObject<{
        visible: zod.ZodOptional<zod.ZodBoolean>;
        disabled: zod.ZodOptional<zod.ZodBoolean>;
        active: zod.ZodOptional<zod.ZodBoolean>;
        loading: zod.ZodOptional<zod.ZodBoolean>;
    }, zod_v4_core.$strip>;
    UtilsSignalUISchema: zod.ZodObject<{
        kind: zod.ZodLiteral<string>;
        event: zod.ZodEnum<{
            [x: string]: string;
        }>;
    }, zod_v4_core.$strip>;
    UtilsSignalSysSchema: zod.ZodObject<{
        kind: zod.ZodLiteral<string>;
        event: zod.ZodEnum<{
            [x: string]: string;
        }>;
    }, zod_v4_core.$strip>;
    UtilsSignalSchema: zod.ZodDiscriminatedUnion<[zod.ZodObject<{
        kind: zod.ZodLiteral<string>;
        event: zod.ZodEnum<{
            [x: string]: string;
        }>;
    }, zod_v4_core.$strip>, zod.ZodObject<{
        kind: zod.ZodLiteral<string>;
        event: zod.ZodEnum<{
            [x: string]: string;
        }>;
    }, zod_v4_core.$strip>], "kind">;
    UtilsEmitSchema: zod.ZodObject<{
        targetId: zod.ZodString;
        elKind: zod.ZodString;
        signal: zod.ZodDiscriminatedUnion<[zod.ZodObject<{
            kind: zod.ZodLiteral<string>;
            event: zod.ZodEnum<{
                [x: string]: string;
            }>;
        }, zod_v4_core.$strip>, zod.ZodObject<{
            kind: zod.ZodLiteral<string>;
            event: zod.ZodEnum<{
                [x: string]: string;
            }>;
        }, zod_v4_core.$strip>], "kind">;
        payload: zod.ZodOptional<zod.ZodUnknown>;
    }, zod_v4_core.$strip>;
    UtilsIsBehaviorSchema: zod.ZodObject<{
        emit: zod.ZodArray<zod.ZodObject<{
            targetId: zod.ZodString;
            elKind: zod.ZodString;
            signal: zod.ZodDiscriminatedUnion<[zod.ZodObject<{
                kind: zod.ZodLiteral<string>;
                event: zod.ZodEnum<{
                    [x: string]: string;
                }>;
            }, zod_v4_core.$strip>, zod.ZodObject<{
                kind: zod.ZodLiteral<string>;
                event: zod.ZodEnum<{
                    [x: string]: string;
                }>;
            }, zod_v4_core.$strip>], "kind">;
            payload: zod.ZodOptional<zod.ZodUnknown>;
        }, zod_v4_core.$strip>>;
    }, zod_v4_core.$strip>;
    UtilsDynamicNodeCore: zod.ZodObject<{
        id: zod.ZodString;
        kind: zod.ZodString;
    }, zod_v4_core.$strip>;
    UtilsIsDynamicCore: zod.ZodObject<{
        id: zod.ZodString;
        kind: zod.ZodString;
        owner: zod.ZodObject<{
            id: zod.ZodString;
            kind: zod.ZodString;
        }, zod_v4_core.$strip>;
    }, zod_v4_core.$strip>;
    EventKindUI: zod.ZodLiteral<string>;
    EventKindSys: zod.ZodLiteral<string>;
    EventActionsUI: zod.ZodEnum<{
        [x: string]: string;
    }>;
    EventActionsSys: zod.ZodEnum<{
        [x: string]: string;
    }>;
    TextTagSchema: zod.ZodEnum<{
        [x: string]: string;
    }>;
    EntitiesKindButton: zod.ZodEnum<{
        [x: string]: string;
    }>;
    EntitiesKindText: zod.ZodLiteral<string>;
    EntitiesKindContainer: zod.ZodLiteral<string>;
    EntitiesKindElements: zod.ZodEnum<{
        [x: string]: string;
    }>;
    EntitiesKindBlocks: zod.ZodEnum<{
        [x: string]: string;
    }>;
    EntitiesKindAll: zod.ZodEnum<{
        [x: string]: string;
    }>;
};

declare const Types: {
    Entities: {
        Kind: {
            container: string;
            button: string;
            link: string;
            text: string;
        };
        Tag: {
            Text_: {
                p: string;
                h1: string;
                h2: string;
                h3: string;
                h4: string;
            };
        };
    };
    Events: {
        UI: {
            onClick: string;
            onMouseEnter: string;
            onMouseLeave: string;
            onFocus: string;
            onBlur: string;
            onKeyDown: string;
            onKeyUp: string;
        };
        Systems: {
            open: string;
            close: string;
            setVisible: string;
            setDisabled: string;
            setActive: string;
            setLoading: string;
        };
        Kind: {
            ui: string;
            system: string;
        };
    };
};

type LayoutType = 'FlexLayout' | 'GridLayout' | 'AbsoluteLayout' | 'InlineLayout' | 'DefaultLayout';
interface AstContainerCore extends NodeCoreStructType<unknown> {
    kind: 'container';
    layout?: LayoutType;
}
interface AstContainerProps {
    className?: string;
    display?: 'flex' | 'grid' | 'inline';
    direction?: 'row' | 'column';
    align?: 'start' | 'center' | 'end';
    gap?: number;
    position?: 'absolute' | 'relative' | 'fixed' | 'static' | 'sticky';
}
interface AstBlockContainerType extends NodeAstConfigType<unknown> {
    core: AstContainerCore;
    props: AstContainerProps;
}

declare function container_config(data: AstBlockContainerType): AstBlockContainerType;

interface AstButtonCore extends NodeCoreStructType<never> {
    kind: 'button' | 'link';
}
interface AstButtonProps {
    className?: string;
    classNameImgWp?: string;
    classNameImg?: string;
    classNameSvg?: string;
    importance?: 'default' | 'main' | 'supplementary';
    backgroundStyle?: string;
    text?: string;
    img?: string;
    svg?: FunctionComponent<SVGProps<SVGSVGElement>>;
    imgLocation?: "left" | "right";
    imgWidth?: number;
    imgHeight?: number;
}
interface AstElementButtonType extends NodeAstConfigType {
    core: AstButtonCore;
    props: AstButtonProps;
}
interface AstTextCore extends NodeCoreStructType {
    kind: 'text';
}
interface AstTextProps {
    className?: string;
    text?: string | number;
    animateTyping?: boolean;
    typingSpeed?: number;
    startDelay?: number;
}
interface AstTextInitialState extends NodeAstStateType {
    tag: ElementType;
}
interface AstElementTextType extends NodeAstConfigType {
    core: AstTextCore;
    initialState: AstTextInitialState;
    props: AstTextProps;
}

declare function text_config(data: AstElementTextType): AstElementTextType;

declare function button_config(data: AstElementButtonType): AstElementButtonType;
declare function button_config_dynamic(data: AstElementButtonType, owner: OwnerDynamicParentType): AstElementButtonType;

declare const Config: {
    Elements: {
        Button: typeof button_config;
        ButtonDynamic: typeof button_config_dynamic;
        Text: typeof text_config;
    };
    Blocks: {
        Container: typeof container_config;
    };
};

type CoreIdAndKind = Pick<NodeCoreStructType, 'id'> & Pick<NodeCoreStructType, 'kind'>;

declare function getActionId({ id, kind }: CoreIdAndKind): {
    signalId: string;
    events: string[];
};
declare function onSignal(signalId: string, events: string): void;

type RuntimeButtonProps = AstButtonProps & NodeAstStateType;
interface RuntimeButtonRegister {
    id: string;
    props: RuntimeButtonProps;
}
interface RuntimeButtonRegisterWithKind extends RuntimeButtonRegister {
    kind: AstButtonCore['kind'];
}

declare const $buttons: effector.StoreWritable<Map<string, RuntimeButtonRegister>>;

type RuntimeChildrenId = Pick<NodeCoreStructType, 'id'> & Pick<NodeCoreStructType, 'kind'>;

type RuntimeContainerProps = AstContainerProps & NodeAstStateType;
interface RuntimeContainerRegister {
    id: string;
    props: RuntimeContainerProps;
}
type RuntimeContainerChildren = {
    id: string;
    children: Array<RuntimeChildrenId>;
};

declare const $containers: effector.StoreWritable<Map<string, RuntimeContainerRegister>>;

declare const $container_children: effector.StoreWritable<Map<string, RuntimeChildrenId[]>>;

type RuntimeTextProps = AstTextProps & AstTextInitialState;
interface RuntimeTextRegister {
    id: string;
    props: RuntimeTextProps;
}

declare const $texts: effector.StoreWritable<Map<string, RuntimeTextRegister>>;

export { $buttons, $container_children, $containers, $texts, type AstBlockContainerType, type AstButtonCore, type AstButtonProps, type AstContainerCore, type AstContainerProps, type AstElementButtonType, type AstElementTextType, type AstTextCore, type AstTextInitialState, type AstTextProps, Config, Engine, type LayoutType, type NodeAstBehaviorType, type NodeAstConfigType, type NodeAstStateType, type NodeCoreStructType, type OwnerDynamicParentType, type RuntimeButtonProps, type RuntimeButtonRegister, type RuntimeButtonRegisterWithKind, type RuntimeContainerChildren, type RuntimeContainerProps, type RuntimeContainerRegister, type RuntimeTextProps, type RuntimeTextRegister, type SignalContract, type SignalSysType, type SignalType, type SignalUIType, type SystemSignalType, Types, type UiEventType, Validator, getActionId, onSignal };
