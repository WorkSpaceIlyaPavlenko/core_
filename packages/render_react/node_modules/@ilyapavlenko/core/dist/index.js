import z5, { z } from 'zod';
import crypto from 'crypto';
import { createEvent, createStore } from 'effector';

// src/types/events/events.ts
var Events = {
  UI: {
    onClick: "onClick",
    onMouseEnter: "onMouseEnter",
    onMouseLeave: "onMouseLeave",
    onFocus: "onFocus",
    onBlur: "onBlur",
    onKeyDown: "onKeyDown",
    onKeyUp: "onKeyUp"
  },
  Systems: {
    open: "open",
    close: "close",
    setVisible: "setVisible",
    setDisabled: "setDisabled",
    setActive: "setActive",
    setLoading: "setLoading"
  },
  Kind: {
    ui: "ui",
    system: "system"
  }
};
var events_default = Events;

// src/types/entities/kind/elements.ts
var Elements = {
  button: "button",
  link: "link",
  text: "text"
};
var elements_default = Elements;

// src/types/entities/kind/blocks.ts
var Blocks = {
  container: "container"
};
var blocks_default = Blocks;

// src/types/entities/kind/kind.ts
var Kind = {
  ...elements_default,
  ...blocks_default
};
var kind_default = Kind;

// src/types/entities/tag.ts
var Text_ = {
  p: "p",
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4"
};
var Tag = {
  Text_
};
var tag_default = Tag;

// src/types/entities/index.ts
var Entities = {
  Kind: kind_default,
  Tag: tag_default
};
var entities_default = Entities;

// src/types/types.ts
var Types = {
  Entities: entities_default,
  Events: events_default
};
var types_default = Types;
var EventActionsUI = z5.enum(Object.values(types_default.Events.UI));
var EventActionsSys = z5.enum(Object.values(types_default.Events.Systems));
var EventActionsSchemas = {
  EventActionsUI,
  EventActionsSys
};
var events_actions_default = EventActionsSchemas;
var AllKindsSchema = z5.enum(Object.values(types_default.Entities.Kind));
var ButtonKindSchema = z5.enum([
  types_default.Entities.Kind.button,
  types_default.Entities.Kind.link
]);
var TextKindSchema = z5.literal(types_default.Entities.Kind.text);
var ElementsKindSchema = z5.enum([
  types_default.Entities.Kind.button,
  types_default.Entities.Kind.link,
  types_default.Entities.Kind.text
]);
var BlocksKindSchema = z5.enum([
  types_default.Entities.Kind.container
]);
var ContainerKindSchema = z5.literal(types_default.Entities.Kind.container);
var KindSchemas = {
  EntitiesKindButton: ButtonKindSchema,
  EntitiesKindText: TextKindSchema,
  EntitiesKindContainer: ContainerKindSchema,
  EntitiesKindElements: ElementsKindSchema,
  EntitiesKindBlocks: BlocksKindSchema,
  EntitiesKindAll: AllKindsSchema
};
var kind_default2 = KindSchemas;
var EventKindUI = z5.literal(types_default.Events.Kind.ui);
var EventKindSys = z5.literal(types_default.Events.Kind.ui);
var EventKindSchemas = {
  EventKindUI,
  EventKindSys
};
var events_kind_default = EventKindSchemas;
var TextTagSchema = z5.enum(Object.values(types_default.Entities.Tag.Text_));
var TagSchemas = {
  TextTagSchema
};
var tag_default2 = TagSchemas;
function isObject(item) {
  return typeof item === "object" && item !== null;
}
setTimeout(() => {
}, 5e3);
var UtilsDynamicNodeCore = z5.object({
  id: z5.string(),
  kind: z5.string()
});
var UtilsIsDynamicCore = z5.object({
  id: z5.string(),
  kind: z5.string(),
  owner: UtilsDynamicNodeCore
});
var UtilsIsNodeCore = z5.object({
  id: z5.string(),
  kind: z5.string(),
  owner: z5.string().nullable().optional(),
  children: z5.array(z5.unknown()).optional(),
  //container
  layout: z5.string().optional()
});
var UtilsIsNodeInitialState = z5.object({
  visible: z5.boolean().optional(),
  disabled: z5.boolean().optional(),
  active: z5.boolean().optional(),
  loading: z5.boolean().optional()
});
var UtilsSignalUISchema = z5.object({
  kind: z5.literal(types_default.Events.Kind.ui),
  event: z5.enum(Object.values(types_default.Events.UI))
});
var UtilsSignalSysSchema = z5.object({
  kind: z5.literal(types_default.Events.Kind.system),
  event: z5.enum(Object.values(types_default.Events.Systems))
});
var UtilsSignalSchema = z5.discriminatedUnion("kind", [
  UtilsSignalUISchema,
  UtilsSignalSysSchema
]);
var UtilsEmitSchema = z5.object({
  targetId: z5.string(),
  elKind: z5.string(),
  signal: UtilsSignalSchema,
  payload: z5.unknown().optional()
});
var UtilsIsBehaviorSchema = z5.object({
  emit: z5.array(UtilsEmitSchema)
});
var Utils = {
  UtilsIsObject: isObject,
  UtilsIsNodeCoreSchema: UtilsIsNodeCore,
  UtilsIsNodeInitialStateSchema: UtilsIsNodeInitialState,
  UtilsSignalUISchema,
  UtilsSignalSysSchema,
  UtilsSignalSchema,
  UtilsEmitSchema,
  UtilsIsBehaviorSchema,
  UtilsDynamicNodeCore,
  UtilsIsDynamicCore
};
var typeof_default = Utils;
var NodeAstStateSchema = z.object({
  visible: z.boolean().optional(),
  disabled: z.boolean().optional(),
  active: z.boolean().optional(),
  loading: z.boolean().optional()
});
var AstButtonPropsSchema = z.object({
  className: z.string().optional(),
  classNameImgWp: z.string().optional(),
  classNameImg: z.string().optional(),
  classNameSvg: z.string().optional(),
  importance: z.enum(["default", "main", "supplementary"]).optional(),
  backgroundStyle: z.string().optional(),
  text: z.string().optional(),
  img: z.unknown().optional(),
  svg: z.unknown().optional(),
  imgLocation: z.enum(["left", "right"]).optional(),
  imgWidth: z.number().optional(),
  imgHeight: z.number().optional()
});
var RuntimePropsButtonSchema = AstButtonPropsSchema.and(NodeAstStateSchema);
var HtmlTagSchema = z.custom(
  (value) => {
    if (typeof value !== "string") return false;
    if (typeof document === "undefined") return false;
    return document.createElement(value).toString() !== "[object HTMLUnknownElement]";
  },
  { message: "Invalid HTML tag name" }
);
var AstTextPropsSchema = z.object({
  className: z.string().optional(),
  text: z.union([z.string(), z.number()]).optional(),
  animateTyping: z.boolean().optional(),
  typingSpeed: z.number().optional(),
  startDelay: z.number().optional()
});
var AstTextInitialStateSchema = z.object({
  tag: HtmlTagSchema
});
var RuntimePropsTextSchema = AstTextPropsSchema.and(AstTextInitialStateSchema).and(NodeAstStateSchema);
var LayoutTypeSchema = z.enum([
  "FlexLayout",
  "GridLayout",
  "AbsoluteLayout",
  "InlineLayout",
  "DefaultLayout"
]);
var AstContainerCoreSchema = z.object({
  kind: z.literal("container"),
  layout: LayoutTypeSchema.optional()
});
var AstContainerPropsSchema = z.object({
  className: z.string().optional(),
  display: z.enum(["flex", "grid", "inline"]).optional(),
  direction: z.enum(["row", "column"]).optional(),
  align: z.enum(["start", "center", "end"]).optional(),
  gap: z.number().optional(),
  position: z.enum([
    "absolute",
    "relative",
    "fixed",
    "static",
    "sticky"
  ]).optional()
});
var RuntimePropsContainerSchema = AstContainerPropsSchema.and(NodeAstStateSchema);
var PropsSchema = {
  NodeAstStateSchema,
  AstButtonPropsSchema,
  RuntimePropsButtonSchema,
  AstTextPropsSchema,
  AstTextInitialStateSchema,
  RuntimePropsTextSchema,
  AstContainerCoreSchema,
  AstContainerPropsSchema,
  RuntimePropsContainerSchema
};
var props_default = PropsSchema;

// src/schemas/validator.ts
var Validator = {
  ...kind_default2,
  ...tag_default2,
  ...events_actions_default,
  ...events_kind_default,
  ...typeof_default,
  ...props_default
};
var validator_default = Validator;

// src/engine/converters/props_converter.ts
var PropsConverter = class {
  constructor(initState, props, core) {
    this.converters = {
      button: () => this.mergeProps(),
      link: () => this.mergeProps(),
      text: () => this.mergeProps(),
      container: () => this.mergeProps()
    };
    this.initStateAST = initState;
    this.propsAST = props;
    this.coreAST = core;
    this.kind = core.kind;
  }
  getProps() {
    const kind = this.kind;
    const fn = this.converters[kind];
    if (!fn)
      return void 0;
    return fn();
  }
  mergeProps() {
    const props = validator_default.UtilsIsObject(this.propsAST) ? this.propsAST : {};
    return {
      id: this.coreAST.id,
      props: {
        ...this.initStateAST ?? {},
        ...props
      }
    };
  }
};
var props_converter_default = PropsConverter;

// src/engine/converters/signal_converter.ts
var SignalConverter = class {
  constructor(core, behavior) {
    this.coreAST = core;
    this.behaviorAST = behavior;
    this.kind = core.kind;
    this.id = core.id;
  }
  getSignals() {
    return this.createRuntimeSignals();
  }
  createRuntimeSignals() {
    if (!this.behaviorAST)
      return void 0;
    const emits = [...this.behaviorAST.emit];
    const runTimeEmits = [];
    for (const emit of emits) {
      const { targetId, targetKind } = this.getEmitsTarget(emit);
      const signal = this.getSignalType(emit);
      if (signal === void 0)
        continue;
      const payload = this.getPayload(targetKind, emit.payload);
      runTimeEmits.push({
        targetId,
        elKind: targetKind,
        signal,
        payload
      });
    }
    console.log(runTimeEmits);
    return { emits: runTimeEmits };
  }
  getEmitsTarget(emit) {
    const targetId = emit.targetId;
    const targetKind = emit.elKind;
    return {
      targetId,
      targetKind
    };
  }
  getSignalType(emit) {
    const signal = emit.signal;
    const { kind, event } = signal;
    if (validator_default.EventKindUI.safeParse(kind).success && validator_default.EventActionsUI.safeParse(event))
      return signal;
    else if (validator_default.EventKindSys.safeParse(kind).success && validator_default.EventActionsSys.safeParse(event))
      return signal;
    return void 0;
  }
  //TODO:заменить as на z валидацию
  getPayload(kind, payload) {
    if (!validator_default.UtilsIsObject(payload))
      return {};
    if (validator_default.EntitiesKindButton.safeParse(kind).success)
      return payload;
    if (validator_default.EntitiesKindContainer.safeParse(kind).success)
      return payload;
    if (validator_default.EntitiesKindText.safeParse(kind).success)
      return payload;
    return {};
  }
};
var signal_converter_default = SignalConverter;

// src/register/utils.ts
function register(map, config) {
  if (!config.id)
    return map;
  const next = new Map(map);
  next.set(config.id, config);
  return next;
}
function update(map, { id, patch }) {
  const config = map.get(id);
  if (!config)
    return map;
  if (!patch.props)
    return map;
  const next = new Map(map);
  next.set(id, {
    ...config,
    ...patch,
    props: {
      ...config.props,
      ...patch.props
    }
  });
  return next;
}
function updateChildren(map, { id, children }) {
  if (!children.length)
    return map;
  const prev = map.get(id) ?? [];
  const merged = /* @__PURE__ */ new Map();
  for (const item of prev)
    merged.set(item.id, item);
  for (const item of children)
    merged.set(item.id, item);
  const next = new Map(map);
  next.set(id, [...merged.values()]);
  return next;
}
function removeChildren(map, { id, children }) {
  if (!children.length)
    return map;
  const prev = map.get(id);
  if (!prev)
    return map;
  const removeIds = new Set(children.map((c) => c.id));
  const filtered = prev.filter((c) => !removeIds.has(c.id));
  const next = new Map(map);
  if (filtered.length)
    next.set(id, filtered);
  else
    next.delete(id);
  return next;
}

// src/register/button_store/button_register.ts
var registerButton = createEvent();
var updateButton = createEvent();
var $buttons = createStore(/* @__PURE__ */ new Map()).on(registerButton, register).on(updateButton, update);

// src/signals/handlers/handler.ts
var Handler = class {
  constructor() {
  }
  register(signalId, data) {
    this.getCollection().set(signalId, data);
  }
  execute(signalId, event) {
    const data = this.getCollection().get(signalId);
    const store = this.getStore();
    console.log(data);
    if (validator_default.EventActionsUI.safeParse(event).success && data) {
      for (const emit of data.emits) {
        const event_ = emit.signal.event;
        if (event_ !== event)
          continue;
        store(this.getPatch(emit));
      }
    } else if (validator_default.EventKindSys.safeParse(event).success && data) {
      for (const emit of data.emits) {
        const event_ = emit.signal.event;
        if (event_ !== event)
          continue;
        store(this.getPatch(emit));
      }
    }
  }
  getEventById(signalId) {
    const data = this.getCollection().get(signalId);
    const events = [];
    if (data)
      for (const emit of data.emits)
        events.push(emit.signal.event);
    return events;
  }
  getPatch(emit) {
    const patch = {
      id: emit.targetId,
      props: emit.payload
    };
    return {
      id: emit.targetId,
      patch
    };
  }
};
var handler_default = Handler;

// src/signals/handlers/button_handler.ts
var ButtonHandler = class extends handler_default {
  constructor() {
    super();
    this.actionsCollection = /* @__PURE__ */ new Map();
  }
  getCollection() {
    return this.actionsCollection;
  }
  getStore() {
    return updateButton;
  }
};
var AppButtonHandler = new ButtonHandler();
var button_handler_default = AppButtonHandler;
var registerText = createEvent();
var updateText = createEvent();
var $texts = createStore(/* @__PURE__ */ new Map()).on(registerText, register).on(updateText, update);

// src/signals/handlers/text_handler.ts
var TextHandler = class extends handler_default {
  constructor() {
    super();
    this.actionsCollection = /* @__PURE__ */ new Map();
  }
  getCollection() {
    return this.actionsCollection;
  }
  getStore() {
    return updateText;
  }
};
var AppTextHandler = new TextHandler();
var text_handler_default = AppTextHandler;
var registerContainer = createEvent();
var updateContainer = createEvent();
var $containers = createStore(/* @__PURE__ */ new Map()).on(registerContainer, register).on(updateContainer, update);

// src/signals/handlers/container_handler.ts
var ContainerHandler = class extends handler_default {
  constructor() {
    super();
    this.actionsCollection = /* @__PURE__ */ new Map();
  }
  getCollection() {
    return this.actionsCollection;
  }
  getStore() {
    return updateContainer;
  }
};
var AppContainerHandler = new ContainerHandler();
var container_handler_default = AppContainerHandler;

// src/signals/signal_register.ts
var SignalRegister = class {
  constructor() {
    this.keySignalsId_ = /* @__PURE__ */ new Map();
    this.signalsIdHandler = /* @__PURE__ */ new Map();
    this.handlers = /* @__PURE__ */ new Map([
      ["AppButtonHandler", button_handler_default],
      ["AppTextHandler", text_handler_default],
      ["AppContainerHandler", container_handler_default]
    ]);
  }
  setSignal({ id, kind }, data) {
    const key = this.getKey({ id, kind });
    const signalID = this.createSignalId(key);
    if (!this.keySignalsId_.has(key)) {
      this.keySignalsId_.set(key, signalID);
      this.provideToHandler(signalID, data);
    }
  }
  getSignalId({ id, kind }) {
    const key = this.getKey({ id, kind });
    return this.keySignalsId_.get(key);
  }
  getEventForId(signalId) {
    const handlerNames = this.signalsIdHandler.get(signalId);
    if (!handlerNames?.length)
      return [];
    const events = [];
    for (const handlerName of handlerNames) {
      const handler = this.getHandler(handlerName);
      if (!handler)
        return [];
      events.push(...handler.getEventById(signalId));
    }
    return events;
  }
  executeSignal(signalId, event) {
    const handlerNames = this.signalsIdHandler.get(signalId);
    if (!handlerNames?.length)
      throw Error("No denied Handlers");
    for (const handlerName of handlerNames) {
      const handler = this.getHandler(handlerName);
      if (!handler)
        throw Error("No denied Handler");
      handler.execute(signalId, event);
    }
  }
  createSignalId(key) {
    const key_ = crypto.createHash("sha256").update(key).digest("hex").slice(0, 16);
    return `sig_${key_}`;
  }
  getKey({ id, kind }) {
    return `${id}-${kind}`;
  }
  provideToHandler(signalId, data) {
    const emitCollection = this.sortEmitsByKind(data);
    for (const [kind, emit] of emitCollection) {
      if (validator_default.EntitiesKindButton.safeParse(kind).success) {
        this.getHandler("AppButtonHandler")?.register(signalId, emit);
        this.setSignalHandler(signalId, "AppButtonHandler");
        continue;
      }
      if (validator_default.EntitiesKindText.safeParse(kind).success) {
        this.getHandler("AppTextHandler")?.register(signalId, data);
        this.setSignalHandler(signalId, "AppTextHandler");
        continue;
      }
      if (validator_default.EntitiesKindContainer.safeParse(kind).success) {
        this.getHandler("AppContainerHandler")?.register(signalId, data);
        this.setSignalHandler(signalId, "AppContainerHandler");
        continue;
      }
    }
  }
  getHandler(handler) {
    if (this.handlers.has(handler))
      return this.handlers.get(handler);
    else
      throw Error("No handler handler found.");
  }
  setSignalHandler(id, handler) {
    const prevHandlers = this.signalsIdHandler.get(id);
    if (prevHandlers && prevHandlers.length) {
      this.signalsIdHandler.set(id, [...prevHandlers, handler]);
    } else
      this.signalsIdHandler.set(id, [handler]);
  }
  sortEmitsByKind(data) {
    const emits = data.emits;
    const kindEmits = /* @__PURE__ */ new Map([]);
    for (const emit of emits) {
      const prev = kindEmits.get(emit.elKind);
      if (prev?.emits.length)
        kindEmits.set(emit.elKind, { emits: [...prev.emits, emit] });
      else
        kindEmits.set(emit.elKind, { emits: [emit] });
    }
    return kindEmits;
  }
};
var AppSignalRegister = new SignalRegister();
var signal_register_default = AppSignalRegister;

// src/engine/validation/validation_props.ts
var ValidationProps = class {
  constructor() {
    this.schemasByKind = /* @__PURE__ */ new Map([
      [
        types_default.Entities.Kind.button,
        (props) => validator_default.RuntimePropsButtonSchema.safeParse(props).success
      ],
      [
        types_default.Entities.Kind.link,
        (props) => validator_default.RuntimePropsButtonSchema.safeParse(props).success
      ],
      [
        types_default.Entities.Kind.text,
        (props) => validator_default.RuntimePropsTextSchema.safeParse(props).success
      ],
      [
        types_default.Entities.Kind.container,
        (props) => validator_default.RuntimePropsContainerSchema.safeParse(props).success
      ]
    ]);
    this.blocksKind = (kind) => validator_default.EntitiesKindContainer.safeParse(kind).success;
  }
  validKind(kind) {
    const parse = validator_default.EntitiesKindAll.safeParse(kind);
    if (parse.success)
      return true;
    else {
      console.error(parse.error);
      return false;
    }
  }
  validRuntimePropsOfKind(kind, id, props) {
    if (!id) {
      console.warn(`Unknown runtime item`);
      return false;
    }
    if (!props) {
      console.warn(`Empty props for item ${id}. Skip register`);
      return false;
    }
    const fn = this.schemasByKind.get(kind);
    if (!fn) {
      console.error(`Undefined kind - ${kind}`);
      return false;
    }
    const parse = fn(props);
    if (parse)
      return true;
    else {
      console.error(`Not correct props structure for Kind: ${kind}`);
      return false;
    }
  }
  isDynamic(item) {
    const parse = validator_default.UtilsIsDynamicCore.safeParse(item);
    if (parse.success)
      return true;
    else {
      console.error(parse.error);
      return false;
    }
  }
  isDynamicCore(item) {
    const parse = validator_default.UtilsDynamicNodeCore.safeParse(item);
    if (parse.success)
      return parse.data;
    else {
      console.error(parse.error);
      return false;
    }
  }
  //TODO:ослабить валидацию для всего кроме core иничае z перезатрет
  castToNodeAstConfig(item) {
    if (!validator_default.UtilsIsObject(item))
      throw Error("Not success format node config");
    if (!("core" in item))
      throw Error("Core is missing node config");
    const parsedCore = validator_default.UtilsIsNodeCoreSchema.safeParse(item.core);
    if (!parsedCore.success)
      this.throwError(parsedCore);
    let parsedInitialState = void 0;
    if ("initialState" in item)
      parsedInitialState = validator_default.UtilsIsNodeInitialStateSchema.safeParse(item.initialState);
    if (parsedInitialState && !parsedInitialState.success)
      this.throwError(parsedInitialState);
    let parsedBehavior = void 0;
    if ("behavior" in item)
      parsedBehavior = validator_default.UtilsIsBehaviorSchema.safeParse(item.behavior);
    if (parsedBehavior && !parsedBehavior.success)
      this.throwError(parsedBehavior);
    let parseProps = void 0;
    if ("props" in item)
      parseProps = item.props;
    return {
      core: parsedCore.data,
      initialState: parsedInitialState?.data ?? void 0,
      behavior: parsedBehavior?.data ?? void 0,
      props: parseProps ?? void 0
    };
  }
  throwError(errs) {
    throw Error(
      "Not correct struct for core: " + errs.error.issues.map((i) => i.path.join(".") + ": " + i.message).join(", ")
    );
  }
};
var addContainerChildren = createEvent();
var deleteChildren = createEvent();
var $container_children = createStore(/* @__PURE__ */ new Map()).on(addContainerChildren, updateChildren).on(deleteChildren, removeChildren);

// src/register/index.ts
var StoresRegisters = /* @__PURE__ */ new Map([
  [types_default.Entities.Kind.button, (data) => registerButton(data)],
  [types_default.Entities.Kind.link, (data) => registerButton(data)],
  [types_default.Entities.Kind.text, (data) => registerText(data)],
  [types_default.Entities.Kind.container, (data) => registerContainer(data)]
]);
var childrenStoresRegisters = /* @__PURE__ */ new Map([
  [types_default.Entities.Kind.container, (data) => addContainerChildren(data)]
]);

// src/engine/providers/store_provider.ts
var StoreProvider = class {
  constructor() {
    this.stores = StoresRegisters;
    this.childrenStore = childrenStoresRegisters;
  }
  /**
   * provie valid props to registers
   */
  provide(kind, props) {
    const fn = this.stores.get(kind);
    if (!fn) {
      console.error(`There is no suitable registry for the ${kind}`);
      return;
    }
    fn(props);
  }
  childIdsProvide(kind, data) {
    const fn = this.childrenStore.get(kind);
    if (!fn) {
      console.error(`There is no suitable registry children for the ${kind}`);
      return;
    }
    fn(data);
  }
};

// src/engine/engine.ts
var Engine = class {
  constructor() {
    this.inRun = /* @__PURE__ */ new Set([]);
    this.childrenIds = /* @__PURE__ */ new Map([]);
    this.validator = new ValidationProps();
    this.provider = new StoreProvider();
  }
  run(config) {
    this.parseNode(config);
  }
  dynamic(data) {
    if (Array.isArray(data))
      for (const item of data) {
        if (this.validator.isDynamic(item.core)) {
          this.run(item);
          this.ownerByChildren(item.core);
        }
      }
    else if (this.validator.isDynamic(data.core)) {
      this.run(data);
      this.ownerByChildren(data.core);
    }
  }
  storeProvider({ core, initialState, props }) {
    const { id, kind } = core;
    const converter = new props_converter_default(initialState, props, core);
    if (!this.validator.validKind(kind))
      return;
    const propsRuntime = converter.getProps();
    if (!propsRuntime || !this.validator.validRuntimePropsOfKind(kind, propsRuntime?.id, propsRuntime?.props))
      return;
    this.provider.provide(kind, propsRuntime);
    this.childrenProvide({ id, kind });
  }
  signalsProvider({ core, behavior }) {
    if (!behavior)
      return;
    const converter = new signal_converter_default(core, behavior);
    const runtimeSignal = converter.getSignals();
    if (!runtimeSignal)
      return;
    signal_register_default.setSignal(core, runtimeSignal);
  }
  parseNode(config) {
    const { core } = config;
    if (this.inRun.has(core.id))
      throw new Error(`Duplicate or cyclic node id: ${core.id}`);
    this.inRun.add(core.id);
    if (this.hasChild(core) && Array.isArray(core.children)) {
      const ids = [];
      for (let i = 0; i < core.children.length; i++) {
        const child = this.validator.castToNodeAstConfig(core.children[i]);
        const { id, kind } = child.core;
        ids.push({ id, kind });
        this.parseNode(child);
      }
      if (ids.length)
        this.setChildrenIds(core.id, ids);
    }
    this.storeProvider(config);
    this.signalsProvider(config);
  }
  hasChild(core) {
    return !!core.children?.length;
  }
  getChildrenIds(id) {
    if (this.childrenIds.has(id))
      return this.childrenIds.get(id);
    return [];
  }
  ownerByChildren(core) {
    const parse = this.validator.isDynamicCore(core.owner);
    if (parse) {
      this.setChildrenIds(parse.id, [{ id: core.id, kind: core.kind }]);
      this.childrenProvide(parse);
    }
  }
  childrenProvide({ id, kind }) {
    if (!this.validator.blocksKind(kind))
      return;
    const children = this.getChildrenIds(id);
    if (!children?.length)
      return;
    this.provider.childIdsProvide(kind, { id, children });
  }
  setChildrenIds(id, children_ids) {
    if (!children_ids.length)
      return;
    const prev = this.childrenIds.get(id) ?? [];
    const map = /* @__PURE__ */ new Map();
    for (const c of [...prev, ...children_ids]) {
      map.set(c.id, c);
    }
    this.childrenIds.set(id, [...map.values()]);
  }
};

// src/configs/elements/button.ts
function button_config(data) {
  const core = setCore(data);
  const initialState = setState(data) ?? {};
  const behavior = setBehavior(data) ?? { emit: [] };
  const props = setProps(data) ?? {};
  return {
    core,
    initialState,
    behavior,
    props
  };
}
function button_config_dynamic(data, owner) {
  const coreWithOwner = {
    core: {
      ...data.core,
      owner
    }
  };
  const core = setCore(coreWithOwner);
  const initialState = setState(data) ?? {};
  const behavior = setBehavior(data) ?? { emit: [] };
  const props = setProps(data) ?? {};
  return {
    core,
    initialState,
    behavior,
    props
  };
}
function setCore(data) {
  return { ...data.core };
}
function setBehavior(data) {
  if (!data.behavior)
    return void 0;
  return { ...data.behavior };
}
function setState(data) {
  if (!data.initialState)
    return {
      visible: true
    };
  return {
    ...data.initialState,
    visible: data.initialState.visible ?? true
  };
}
function setProps(data) {
  if (!data.props)
    return void 0;
  const props = { ...data.props };
  if (props.img) {
    if (!props.imgLocation)
      props.imgLocation = "left";
  }
  return { ...props };
}

// src/configs/elements/text.ts
function text_config(data) {
  const core = setCore2(data);
  const behavior = setBehavior2(data) ?? { emit: [] };
  const initialState = setState2(data);
  const props = setProps2(data) ?? {};
  return {
    core,
    initialState,
    behavior,
    props
  };
}
function setCore2(data) {
  return { ...data.core };
}
function setBehavior2(data) {
  if (!data.behavior)
    return void 0;
  return { ...data.behavior };
}
function setState2(data) {
  if (!data.initialState)
    return {
      visible: true,
      tag: "p"
    };
  return {
    ...data.initialState,
    visible: data.initialState.visible ?? true,
    tag: setTextTag(data.initialState.tag)
  };
}
function setTextTag(tag) {
  return validator_default.TextTagSchema.safeParse(tag).success ? tag : "p";
}
function setProps2(data) {
  if (!data.props)
    return void 0;
  const props = { ...data.props };
  return { ...props };
}

// src/configs/elements/index.ts
var Elements2 = {
  Button: button_config,
  ButtonDynamic: button_config_dynamic,
  Text: text_config
};
var elements_default2 = Elements2;

// src/configs/blocks/container.ts
function container_config(data) {
  const core = setCore3(data);
  return {
    core,
    behavior: setBehavior3(data) ?? { emit: [] },
    initialState: setState3(data) ?? {},
    props: setProps3(data.props, core)
  };
}
function setCore3(data) {
  const { core } = data;
  return {
    ...core,
    layout: core.layout ?? "DefaultLayout"
  };
}
function setBehavior3(data) {
  if (!data.behavior)
    return void 0;
  return { ...data.behavior };
}
function setState3(data) {
  if (!data.initialState)
    return {
      visible: true
    };
  return {
    ...data.initialState,
    visible: data.initialState.visible ?? true
  };
}
function setProps3(props, core) {
  const base = props ? { ...props } : {};
  const layout = core.layout ?? "DefaultLayout";
  switch (layout) {
    case "FlexLayout": {
      return {
        ...base,
        display: "flex",
        direction: base.direction ?? "row",
        align: base.align ?? "start",
        gap: base.gap ?? 0
      };
    }
    case "GridLayout": {
      return {
        ...base,
        display: "grid",
        gap: base.gap ?? 0
        // колонки / строки можно добавить позже
      };
    }
    case "AbsoluteLayout": {
      return {
        ...base,
        position: base.position ?? "absolute"
      };
    }
    case "InlineLayout": {
      return {
        ...base,
        display: "inline"
      };
    }
    case "DefaultLayout":
    default: {
      return {
        ...base
      };
    }
  }
}

// src/configs/blocks/index.ts
var Blocks2 = {
  Container: container_config
};
var blocks_default2 = Blocks2;

// src/configs/main.ts
var Config = {
  Elements: elements_default2,
  Blocks: blocks_default2
};
var main_default = Config;

// src/signals/signals.ts
function getActionId({ id, kind }) {
  const signalId = signal_register_default.getSignalId({ id, kind });
  const events = signal_register_default.getEventForId(signalId);
  return {
    signalId,
    events
  };
}
function onSignal(signalId, events) {
  signal_register_default.executeSignal(signalId, events);
}

export { $buttons, $container_children, $containers, $texts, main_default as Config, Engine, types_default as Types, validator_default as Validator, getActionId, onSignal };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map